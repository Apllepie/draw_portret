import cv2
import numpy as np
import matplotlib.pyplot as plt
from collections import deque

#params
#photo_path = "photos/photo2.jpg"
photo_path = "simple_photos/fish.png"

LS_path = "LS/DRAW.ls"

SHOW_IMAGE = True
SHAPE_LENGTH_THRESHOLD = 10  # minimum number of points to consider a shape

# Fanuc parameters
SCALE_FACTOR = 0.1  # scale factor for converting pixels to mm
Z_UP = 10.0         # pen up height
Z_DOWN = 0.0        # pen down height
FEED_RATE = 200     # feed rate mm/sec
BASE_X = 0.0        # base X position
BASE_Y = 0.0        # base Y position

UT = 9
UF = 4

def convert_to_fanuc_ls(shape, output_path):
    """converts the shape points to FANUC LS format and saves to a file"""
    
    with open(output_path, 'w') as f:
        # Заголовок программы
        f.write("/PROG DRAW\n")
        f.write("/ATTR\n")
        f.write("OWNER\t\t= ASCBIN;\n")
        f.write("COMMENT\t\t= \"\";\n")
        f.write("/MN\n")
        
        line_num = 1
        current_shape = []
        
        pos_ = []
        # start position
        f.write(f"   {line_num}:   UFRAME_NUM=4\n")
        line_num += 1
       # f.write(f"   {line_num}:J P[{pos_num}] {FEED_RATE}% CNT0 ;\n")
       # line_num += 1
       #pos_num =
        
        shape_count = 0
        pos_num = 1
        
        for point in shape:
            if point == "/":
                if current_shape:
                    shape_count += 1
                    f.write(f"   {line_num}:  !Shape {shape_count} ;\n")
                    line_num += 1
                    
                    # going to the first point of the shape with pen up
                    first_point = current_shape[0]
                    x = BASE_X + first_point[1] * SCALE_FACTOR
                    y = BASE_Y + first_point[0] * SCALE_FACTOR
                    
                    f.write(f"   {line_num}:L P[{pos_num}] {FEED_RATE}mm/sec CNT0 ;\n")
                    pos_.append((x, y, Z_UP)) 
                    line_num += 1
                    pos_num =+ 1

                    # lowering the pen
                    f.write(f"   {line_num}:L P[{pos_num}] {FEED_RATE//2}mm/sec CNT0 ;\n")
                    pos_.append((x, y, Z_DOWN)) 

                    line_num += 1
                    pos_num +=1

                    # drawing the outline
                    for i, point_coord in enumerate(current_shape[1:], 1):
                        x = BASE_X + point_coord[1] * SCALE_FACTOR
                        y = BASE_Y + point_coord[0] * SCALE_FACTOR

                        f.write(f"   {line_num}:L P[{pos_num}] {FEED_RATE//4}mm/sec CNT0 ;\n")
                        pos_.append((x, y, Z_DOWN))
                        line_num += 1
                        pos_num += 1
                        
                        # blocking too long shapes
                        if i > 100:
                            break

                    # lifting the pen
                    last_point = current_shape[min(100, len(current_shape)-1)]
                    x = BASE_X + last_point[1] * SCALE_FACTOR
                    y = BASE_Y + last_point[0] * SCALE_FACTOR

                    f.write(f"   {line_num}:L P[{pos_num}] {FEED_RATE//2}mm/sec CNT0 ;\n")
                    pos_.append((x, y, Z_DOWN))
                    line_num += 1
                    pos_num += 1
                    
                current_shape = []
            else:
                current_shape.append(point)

        # Return to start position
        f.write(f"   {line_num}:L P[1] {FEED_RATE}% CNT0 ;\n")
        line_num += 1

        # End of program
        f.write(f"   {line_num}:  !End of program ;\n")
        f.write("/POS\n")
        npos = 1
        for x, y, z in  pos_:
            f.write ("P[" + str(npos) + "]{\n")
            f.write("\tGP1:\n")
            f.write(f"\t UF : 4, UT : 9,		CONFIG : 'F U T, 0, 0, 0',\n")
            f.write(f"\t X =     {x:.3f}  mm,	Y =   {y:.3f}  mm,	Z =      {z:.3f}  mm,\n")
            f.write(f"\t W =    59.855 deg,	P =   -83.452 deg,	R =  -153.620 deg\n")
            f.write("};\n")
            npos += 1
        
        
        f.write("/END\n")
    
    print(f"FANUC program saved to: {output_path}")
    print(f"Total shapes processed: {shape_count}")


def make_shapes(edge):
    """finds all shapes in the edge image and returns a list of points"""
    shape = []
    visited = np.zeros_like(edge, dtype=bool)
    height, width = edge.shape
    
    def bfs(start_x, start_y):
        """Breadth-First Search to find all connected points of a shape"""
        current_shape = []
        queue = deque([(start_x, start_y)])
        
        while queue:
            x, y = queue.popleft()
            
            if (x < 0 or x >= height or y < 0 or y >= width or 
                visited[x, y] or edge[x, y] == 0):
                continue
            
            visited[x, y] = True
            current_shape.append((x, y))
            
            # Check all 8 directions
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    new_x, new_y = x + dx, y + dy
                    if (0 <= new_x < height and 0 <= new_y < width and 
                        not visited[new_x, new_y] and edge[new_x, new_y] != 0):
                        queue.append((new_x, new_y))
        
        return current_shape

    # Find all connected components
    for i in range(height):
        for j in range(width):
            if edge[i, j] != 0 and not visited[i, j]:
                current_shape = bfs(i, j)
                
                # Filter out small shapes
                if len(current_shape) > SHAPE_LENGTH_THRESHOLD:
                    shape.extend(current_shape)
                    shape.append("/")
    
    return shape

def check_graphicaly(shape):
    """draws the found shapes using matplotlib"""
    plt.figure(figsize=(12, 8))
    
    x = []
    y = []
    colors = plt.cm.tab10(np.linspace(0, 1, 20))
    figure_n = 0
    
    for point in shape:
        if point == "/":
            if x and y:
                color = colors[figure_n % len(colors)]
                plt.scatter(y, x, s=1, color=color, alpha=0.7)
                figure_n += 1
            x = []
            y = []
        else:
            px, py = point
            x.append(px)
            y.append(py)
    
    if x and y:
        color = colors[figure_n % len(colors)]
        plt.scatter(y, x, s=1, color=color, alpha=0.7)
        figure_n += 1
    
    plt.axis("equal")
    plt.grid(True, alpha=0.3)
    plt.title(f"Found {figure_n} shapes")
    plt.gca().invert_yaxis()
    plt.tight_layout()
    plt.show()
    
    print(f"Total shapes found: {figure_n}")

def main():
    image = cv2.imread(photo_path, cv2.IMREAD_GRAYSCALE)
    if image is None:
        print(f"Error: Unable to load image at {photo_path}")
        return
    
    # blur and edge detection
    image = cv2.GaussianBlur(image, (3, 3), 0)
    edge = cv2.Canny(image, 50, 150)

    if SHOW_IMAGE:
        cv2.imshow("Original", image)
        cv2.imshow("Edges", edge)

    shape = make_shapes(edge.copy())
    print(f"Total points found: {len([p for p in shape if p != '/'])}")
    check_graphicaly(shape)

    convert_to_fanuc_ls(shape, LS_path)
    print("✅ FANUC LS file created!")
    
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
